{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _getIterator from 'babel-runtime/core-js/get-iterator';\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\nimport { parse_phone_number_and_country_phone_code, VALID_PUNCTUATION } from './parse';\nimport { get_phone_code, get_formats, get_format_pattern, get_format_format, get_format_leading_digits_patterns, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_optional_when_formatting, get_format_international_format, get_metadata_by_country_phone_code } from './metadata';\nvar default_options = {\n  formatExtension: function formatExtension(number, extension) {\n    return number + ' ext. ' + extension;\n  }\n\n  // Formats a phone number\n  //\n  // Example use cases:\n  //\n  // ```js\n  // format('8005553535', 'RU', 'International')\n  // format('8005553535', 'RU', 'International', metadata)\n  // format({ phone: '8005553535', country: 'RU' }, 'International')\n  // format({ phone: '8005553535', country: 'RU' }, 'International', metadata)\n  // format('+78005553535', 'National')\n  // format('+78005553535', 'National', metadata)\n  // ```\n  //\n};\nexport default function format(arg_1, arg_2, arg_3, arg_4, arg_5) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3, arg_4, arg_5),\n    input = _sort_out_arguments.input,\n    format_type = _sort_out_arguments.format_type,\n    options = _sort_out_arguments.options,\n    metadata = _sort_out_arguments.metadata;\n  var country_metadata = void 0;\n  if (input.country) {\n    country_metadata = metadata.countries[input.country];\n  }\n  var _parse_phone_number_a = parse_phone_number_and_country_phone_code(input.phone, metadata),\n    country_phone_code = _parse_phone_number_a.country_phone_code,\n    number = _parse_phone_number_a.number;\n  if (country_phone_code) {\n    // Check country restriction\n    if (input.country && country_metadata && country_phone_code !== get_phone_code(country_metadata)) {\n      return input.phone;\n    }\n    country_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata);\n  }\n  if (!country_metadata) {\n    return input.phone;\n  }\n  switch (format_type) {\n    case 'International':\n      if (!number) {\n        return '+' + get_phone_code(country_metadata);\n      }\n      var national_number = format_national_number(number, 'International', false, country_metadata);\n      var international_number = '+' + get_phone_code(country_metadata) + ' ' + national_number;\n      if (input.ext || input.ext === 0) {\n        return options.formatExtension(international_number, input.ext);\n      }\n      return international_number;\n    case 'E.164':\n    // \"International_plaintext\" is deprecated\n    case 'International_plaintext':\n      // `E.164` doesn't define \"phone number extensions\".\n      return '+' + get_phone_code(country_metadata) + input.phone;\n    case 'RFC3966':\n      return '+' + get_phone_code(country_metadata) + input.phone + (input.ext || input.ext === 0 ? ';ext=' + input.ext : '');\n    case 'National':\n      if (!number) {\n        return '';\n      }\n      var _national_number = format_national_number(number, 'National', false, country_metadata);\n      if (input.ext || input.ext === 0) {\n        return options.formatExtension(_national_number, input.ext);\n      }\n      return _national_number;\n  }\n}\n\n// This was originally set to $1 but there are some countries for which the\n// first group is not used in the national pattern (e.g. Argentina) so the $1\n// group does not match correctly.  Therefore, we use \\d, so that the first\n// group actually used in the pattern will be matched.\nexport var FIRST_GROUP_PATTERN = /(\\$\\d)/;\nexport function format_national_number_using_format(number, format, international, enforce_national_prefix, country_metadata) {\n  var format_pattern_matcher = new RegExp(get_format_pattern(format));\n  var national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, country_metadata);\n\n  // National prefix is omitted if there's no national prefix formatting rule\n  // set for this country, or when this rule is set but\n  // national prefix is optional for this phone number format\n  // (and it is not enforced explicitly)\n  var national_prefix_may_be_omitted = !national_prefix_formatting_rule || national_prefix_formatting_rule && get_format_national_prefix_is_optional_when_formatting(format, country_metadata) && !enforce_national_prefix;\n  if (!international && !national_prefix_may_be_omitted) {\n    return number.replace(format_pattern_matcher, get_format_format(format).replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule));\n  }\n  var formatted_number = number.replace(format_pattern_matcher, international ? get_format_international_format(format) : get_format_format(format));\n  if (international) {\n    return local_to_international_style(formatted_number);\n  }\n  return formatted_number;\n}\nexport function format_national_number(number, format_as, enforce_national_prefix, country_metadata) {\n  var format = choose_format_for_number(get_formats(country_metadata), number);\n  if (!format) {\n    return number;\n  }\n  return format_national_number_using_format(number, format, format_as === 'International', enforce_national_prefix, country_metadata);\n}\nexport function choose_format_for_number(available_formats, national_number) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = _getIterator(available_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _format = _step.value;\n\n      // Validate leading digits\n      if (get_format_leading_digits_patterns(_format).length > 0) {\n        // The last leading_digits_pattern is used here, as it is the most detailed\n        var last_leading_digits_pattern = get_format_leading_digits_patterns(_format)[get_format_leading_digits_patterns(_format).length - 1];\n\n        // If leading digits don't match then move on to the next phone number format\n        if (national_number.search(last_leading_digits_pattern) !== 0) {\n          continue;\n        }\n      }\n\n      // Check that the national number matches the phone number format regular expression\n      if (matches_entirely(national_number, new RegExp(get_format_pattern(_format)))) {\n        return _format;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n// Removes brackets and replaces dashes with spaces.\n//\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\n//\nexport function local_to_international_style(local) {\n  return local.replace(new RegExp('[' + VALID_PUNCTUATION + ']+', 'g'), ' ').trim();\n}\n\n// Sort out arguments\nfunction sort_out_arguments() {\n  var arg_1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var arg_2 = arguments[1];\n  var arg_3 = arguments[2];\n  var arg_4 = arguments[3];\n  var arg_5 = arguments[4];\n  var input = void 0;\n  var format_type = void 0;\n  var options = void 0;\n  var metadata = void 0;\n\n  // Sort out arguments.\n\n  // If the phone number is passed as a string.\n  // `format('8005553535', ...)`.\n  if (typeof arg_1 === 'string') {\n    // If country code is supplied.\n    // `format('8005553535', 'RU', 'National', [options], metadata)`.\n    if (typeof arg_3 === 'string') {\n      // Will be `parse()`d later in code\n      input = {\n        phone: arg_1,\n        country: arg_2\n      };\n      format_type = arg_3;\n      if (arg_5) {\n        options = arg_4;\n        metadata = arg_5;\n      } else {\n        metadata = arg_4;\n      }\n    }\n    // Just an international phone number is supplied\n    // `format('+78005553535', 'National', [options], metadata)`.\n    else {\n      // Will be `parse()`d later in code\n      input = {\n        phone: arg_1\n      };\n      if (typeof arg_2 !== 'string') {\n        throw new Error('Format type argument not passed for `format()`');\n      }\n      format_type = arg_2;\n      if (arg_4) {\n        options = arg_3;\n        metadata = arg_4;\n      } else {\n        metadata = arg_3;\n      }\n    }\n  }\n  // If the phone number is passed as a parsed number object.\n  // `format({ phone: '8005553535', country: 'RU' }, 'National', [options], metadata)`.\n  else {\n    input = arg_1;\n    format_type = arg_2;\n    if (arg_4) {\n      options = arg_3;\n      metadata = arg_4;\n    } else {\n      metadata = arg_3;\n    }\n  }\n\n  // Metadata is required.\n  if (!metadata) {\n    throw new Error('Metadata is required');\n  }\n\n  // Validate `format_type`.\n  switch (format_type) {\n    case 'International':\n    case 'E.164':\n    // \"International_plaintext\" is deprecated\n    case 'International_plaintext':\n    case 'National':\n    case 'RFC3966':\n      break;\n    default:\n      throw new Error('Unknown format type argument passed to \"format()\": \"' + format_type + '\"');\n  }\n\n  // Apply default options.\n  if (options) {\n    options = _extends({}, default_options, options);\n  } else {\n    options = default_options;\n  }\n  return {\n    input: input,\n    format_type: format_type,\n    options: options,\n    metadata: metadata\n  };\n}\n//# sourceMappingURL=format.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}