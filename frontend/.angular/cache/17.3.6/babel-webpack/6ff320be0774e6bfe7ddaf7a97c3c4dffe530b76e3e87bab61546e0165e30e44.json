{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _getIterator from 'babel-runtime/core-js/get-iterator';\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\nimport { get_phone_code, get_national_number_pattern, get_national_prefix_for_parsing, get_national_prefix_transform_rule, get_leading_digits, get_metadata_by_country_phone_code, get_formats } from\n// get_format_national_prefix_is_mandatory_when_formatting\n'./metadata';\nimport { choose_format_for_number } from './format';\nimport get_number_type from './types';\n\n// The maximum length of the country calling code.\nvar MAX_LENGTH_COUNTRY_CODE = 3;\n\n// The minimum length of the national significant number.\nvar MIN_LENGTH_FOR_NSN = 2;\n\n// The ITU says the maximum length should be 15,\n// but one can find longer numbers in Germany.\nvar MAX_LENGTH_FOR_NSN = 17;\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nvar MAX_INPUT_STRING_LENGTH = 250;\nexport var PLUS_CHARS = '+\\uFF0B';\n\n// Digits accepted in phone numbers\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\nexport var VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9';\n\n// `DASHES` will be right after the opening square bracket of the \"character class\"\nvar DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D';\nvar SLASHES = '\\uFF0F/';\nvar DOTS = '\\uFF0E.';\nvar WHITESPACE = ' \\xA0\\xAD\\u200B\\u2060\\u3000';\nvar BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]';\nvar TILDES = '~\\u2053\\u223C\\uFF5E';\n\n// Regular expression of acceptable punctuation found in phone numbers. This\n// excludes punctuation found as a leading character only. This consists of dash\n// characters, white space characters, full stops, slashes, square brackets,\n// parentheses and tildes. Full-width variants are also present.\nexport var VALID_PUNCTUATION = '' + DASHES + SLASHES + DOTS + WHITESPACE + BRACKETS + TILDES;\n\n// Pattern to capture digits used in an extension.\n// Places a maximum length of '7' for an extension.\nvar CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})';\n\n// The RFC 3966 format for extensions.\nvar RFC3966_EXTN_PREFIX = ';ext=';\n\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\nvar EXTN_PATTERNS_FOR_PARSING = RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + '|' + '[ \\xA0\\\\t,]*' + '(?:e?xt(?:ensi(?:o\\u0301?|\\xF3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' + '[;,x\\uFF58#\\uFF03~\\uFF5E]|int|anexo|\\uFF49\\uFF4E\\uFF54)' + '[:\\\\.\\uFF0E]?[ \\xA0\\\\t,-]*' + CAPTURING_EXTN_DIGITS + '#?|' + '[- ]+([' + VALID_DIGITS + ']{1,5})#';\n\n// Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\nvar EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i');\n\n//  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  \"Note VALID_PUNCTUATION starts with a -,\n//   so must be the first in the range\" (c) Google devs.\n//  (wtf did they mean by saying that; probably nothing)\n//\nvar MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}';\n//\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\nvar VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\n\n// The combined regular expression for valid phone numbers:\n//\nvar VALID_PHONE_NUMBER_PATTERN = new RegExp(\n// Either a short two-digit-only phone number\n'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' +\n// Or a longer fully parsed phone number (min 3 characters)\n'^' + VALID_PHONE_NUMBER +\n// Phone number extensions\n'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' + '$', 'i');\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']');\n\n// Regular expression of trailing characters that we want to remove.\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$');\nvar LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+');\n\n// These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport var DIGIT_MAPPINGS = {\n  '0': '0',\n  '1': '1',\n  '2': '2',\n  '3': '3',\n  '4': '4',\n  '5': '5',\n  '6': '6',\n  '7': '7',\n  '8': '8',\n  '9': '9',\n  '\\uFF10': '0',\n  // Fullwidth digit 0\n  '\\uFF11': '1',\n  // Fullwidth digit 1\n  '\\uFF12': '2',\n  // Fullwidth digit 2\n  '\\uFF13': '3',\n  // Fullwidth digit 3\n  '\\uFF14': '4',\n  // Fullwidth digit 4\n  '\\uFF15': '5',\n  // Fullwidth digit 5\n  '\\uFF16': '6',\n  // Fullwidth digit 6\n  '\\uFF17': '7',\n  // Fullwidth digit 7\n  '\\uFF18': '8',\n  // Fullwidth digit 8\n  '\\uFF19': '9',\n  // Fullwidth digit 9\n  '\\u0660': '0',\n  // Arabic-indic digit 0\n  '\\u0661': '1',\n  // Arabic-indic digit 1\n  '\\u0662': '2',\n  // Arabic-indic digit 2\n  '\\u0663': '3',\n  // Arabic-indic digit 3\n  '\\u0664': '4',\n  // Arabic-indic digit 4\n  '\\u0665': '5',\n  // Arabic-indic digit 5\n  '\\u0666': '6',\n  // Arabic-indic digit 6\n  '\\u0667': '7',\n  // Arabic-indic digit 7\n  '\\u0668': '8',\n  // Arabic-indic digit 8\n  '\\u0669': '9',\n  // Arabic-indic digit 9\n  '\\u06F0': '0',\n  // Eastern-Arabic digit 0\n  '\\u06F1': '1',\n  // Eastern-Arabic digit 1\n  '\\u06F2': '2',\n  // Eastern-Arabic digit 2\n  '\\u06F3': '3',\n  // Eastern-Arabic digit 3\n  '\\u06F4': '4',\n  // Eastern-Arabic digit 4\n  '\\u06F5': '5',\n  // Eastern-Arabic digit 5\n  '\\u06F6': '6',\n  // Eastern-Arabic digit 6\n  '\\u06F7': '7',\n  // Eastern-Arabic digit 7\n  '\\u06F8': '8',\n  // Eastern-Arabic digit 8\n  '\\u06F9': '9' // Eastern-Arabic digit 9\n};\nvar default_options = {\n  country: {}\n\n  // `options`:\n  //  {\n  //    country:\n  //    {\n  //      restrict - (a two-letter country code)\n  //                 the phone number must be in this country\n  //\n  //      default - (a two-letter country code)\n  //                default country to use for phone number parsing and validation\n  //                (if no country code could be derived from the phone number)\n  //    }\n  //  }\n  //\n  // Returns `{ country, number }`\n  //\n  // Example use cases:\n  //\n  // ```js\n  // parse('8 (800) 555-35-35', 'RU')\n  // parse('8 (800) 555-35-35', 'RU', metadata)\n  // parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n  // parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n  // parse('+7 800 555 35 35')\n  // parse('+7 800 555 35 35', metadata)\n  // ```\n  //\n};\nexport default function parse(arg_1, arg_2, arg_3) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3),\n    text = _sort_out_arguments.text,\n    options = _sort_out_arguments.options,\n    metadata = _sort_out_arguments.metadata;\n\n  // Validate country codes\n\n  // Validate `default` country\n\n  if (options.country.default && !metadata.countries[options.country.default]) {\n    throw new Error('Unknown country code: ' + options.country.default);\n  }\n\n  // Validate `restrict` country\n  if (options.country.restrict && !metadata.countries[options.country.restrict]) {\n    throw new Error('Unknown country code: ' + options.country.restrict);\n  }\n\n  // Parse the phone number\n\n  var formatted_phone_number = void 0;\n  var extension = void 0;\n\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = _getIterator(text.split(';')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        var _part$split = part.split(':'),\n          _part$split2 = _slicedToArray(_part$split, 2),\n          name = _part$split2[0],\n          value = _part$split2[1];\n        switch (name) {\n          case 'tel':\n            formatted_phone_number = value;\n            break;\n          case 'ext':\n            extension = value;\n            break;\n          case 'phone-context':\n            // Domain contexts are ignored.\n            if (value[0] === '+') {\n              formatted_phone_number = value + formatted_phone_number;\n            }\n            break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    formatted_phone_number = extract_formatted_phone_number(text);\n  }\n\n  // If the phone number is not viable, then abort.\n  if (!is_viable_phone_number(formatted_phone_number)) {\n    return {};\n  }\n\n  // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n  var with_extension_stripped = strip_extension(formatted_phone_number);\n  if (with_extension_stripped.extension) {\n    formatted_phone_number = with_extension_stripped.number, extension = with_extension_stripped.extension;\n  }\n  var _parse_phone_number_a = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata),\n    country_phone_code = _parse_phone_number_a.country_phone_code,\n    number = _parse_phone_number_a.number;\n\n  // Maybe invalid country phone code encountered\n\n  if (!number) {\n    return {};\n  }\n  var country = void 0;\n  var country_metadata = void 0;\n\n  // Whether the phone number is formatted as an international phone number\n  var is_international = false;\n  if (country_phone_code) {\n    is_international = true;\n\n    // Check country restriction\n    if (options.country.restrict && country_phone_code !== get_phone_code(metadata.countries[options.country.restrict])) {\n      return {};\n    }\n\n    // Formatting information for regions which share\n    // a country calling code is contained by only one region\n    // for performance reasons. For example, for NANPA region\n    // (\"North American Numbering Plan Administration\",\n    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n    // it will be contained in the metadata for `US`.\n    country_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata);\n\n    // `country` will be set later,\n    // because, for example, for NANPA countries\n    // there are several countries corresponding\n    // to the same `1` country phone code.\n    // Therefore, to reliably determine the exact country,\n    // national (significant) number should be parsed first.\n  } else if (options.country.restrict || options.country.default) {\n    country = options.country.restrict || options.country.default;\n    country_metadata = metadata.countries[country];\n    number = normalize(formatted_phone_number);\n  }\n  if (!country_metadata) {\n    return {};\n  }\n  var national_number = number;\n\n  // Only strip national prefixes for non-international phone numbers\n  // because national prefixes can't be present in international phone numbers.\n  // Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\n  // first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\n  // and then it would assume that's a valid number which it isn't.\n  // So no forgiveness for grandmas here.\n  // The issue asking for this fix:\n  // https://github.com/catamphetamine/libphonenumber-js/issues/159\n  if (!is_international) {\n    national_number = strip_national_prefix(number, country_metadata);\n  }\n  var did_have_national_prefix = national_number !== number;\n\n  // https://github.com/catamphetamine/libphonenumber-js/issues/67\n  // if (!is_international && !did_have_national_prefix &&\n  // \t\tis_national_prefix_required(national_number, country_metadata))\n  // {\n  // \treturn {}\n  // }\n\n  // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  if (!country) {\n    // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n    // get their countries populated with the full set of\n    // \"phone number type\" regular expressions.\n    country = find_country_code(country_phone_code, national_number, metadata);\n\n    // Just in case there appears to be a bug in Google's metadata\n    // and the exact country could not be extracted from the phone number.\n    /* istanbul ignore if */\n    if (!country) {\n      return {};\n    }\n\n    // Update metadata to be for this specific country\n    country_metadata = metadata.countries[country];\n  }\n\n  // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n  if (national_number.length > MAX_LENGTH_FOR_NSN) {\n    return {};\n  }\n\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n  var national_number_rule = new RegExp(get_national_number_pattern(country_metadata));\n\n  // Check if national phone number pattern matches the number\n  if (!matches_entirely(national_number, national_number_rule)) {\n    return {};\n  }\n  var result = {\n    country: country,\n    phone: national_number\n  };\n  if (extension) {\n    result.ext = extension;\n  }\n  return result;\n}\n\n// Normalizes a string of characters representing a phone number.\n// This converts wide-ascii and arabic-indic numerals to European numerals,\n// and strips punctuation and alpha characters.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport function normalize(number) {\n  return replace_characters(number, DIGIT_MAPPINGS);\n}\n\n// For any character not being part of `replacements`\n// it is removed from the phone number.\nexport function replace_characters(text, replacements) {\n  var replaced = '';\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n  try {\n    for (var _iterator2 = _getIterator(text), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var character = _step2.value;\n      var replacement = replacements[character.toUpperCase()];\n      if (replacement !== undefined) {\n        replaced += replacement;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n  return replaced;\n}\n\n// Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\nexport function is_viable_phone_number(number) {\n  return number.length >= MIN_LENGTH_FOR_NSN && matches_entirely(number, VALID_PHONE_NUMBER_PATTERN);\n}\nexport function extract_formatted_phone_number(text) {\n  if (!text || text.length > MAX_INPUT_STRING_LENGTH) {\n    return '';\n  }\n\n  // Attempt to extract a possible number from the string passed in\n\n  var starts_at = text.search(PHONE_NUMBER_START_PATTERN);\n  if (starts_at < 0) {\n    return '';\n  }\n  return text\n  // Trim everything to the left of the phone number\n  .slice(starts_at)\n  // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n\n// Parses a formatted phone number.\nexport function parse_phone_number(number) {\n  if (!number) {\n    return '';\n  }\n  var is_international = LEADING_PLUS_CHARS_PATTERN.test(number);\n\n  // Remove non-digits\n  // (and strip the possible leading '+')\n  number = normalize(number);\n  if (is_international) {\n    return '+' + number;\n  }\n  return number;\n}\n\n// Parses a formatted phone number\n// and returns `{ country_phone_code, number }`\n// where `number` is the national (significant) phone number.\n//\n// (aka `maybeExtractCountryPhoneCode`)\n//\nexport function parse_phone_number_and_country_phone_code(number, metadata) {\n  number = parse_phone_number(number);\n  if (!number) {\n    return {};\n  }\n\n  // If this is not an international phone number,\n  // then don't extract country phone code.\n  if (number[0] !== '+') {\n    return {\n      number: number\n    };\n  }\n\n  // Strip the leading '+' sign\n  number = number.slice(1);\n\n  // Fast abortion: country codes do not begin with a '0'\n  if (number[0] === '0') {\n    return {};\n  }\n\n  // The thing with country phone codes\n  // is that they are orthogonal to each other\n  // i.e. there's no such country phone code A\n  // for which country phone code B exists\n  // where B starts with A.\n  // Therefore, while scanning digits,\n  // if a valid country code is found,\n  // that means that it is the country code.\n  //\n  var i = 1;\n  while (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\n    var country_phone_code = number.slice(0, i);\n    if (metadata.country_phone_code_to_countries[country_phone_code]) {\n      return {\n        country_phone_code: country_phone_code,\n        number: number.slice(i)\n      };\n    }\n    i++;\n  }\n  return {};\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided\nexport function strip_national_prefix(number, country_metadata) {\n  var national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata);\n  if (!number || !national_prefix_for_parsing) {\n    return number;\n  }\n\n  // Attempt to parse the first digits as a national prefix\n  var national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')');\n  var national_prefix_matcher = national_prefix_pattern.exec(number);\n\n  // If no national prefix is present in the phone number,\n  // but if the national prefix is optional for this country,\n  // then consider this phone number valid.\n  //\n  // Google's reference `libphonenumber` implementation\n  // wouldn't recognize such phone numbers as valid,\n  // but I think it would perfectly make sense\n  // to consider such phone numbers as valid\n  // because if a national phone number was originally\n  // formatted without the national prefix\n  // then it must be parseable back into the original national number.\n  // In other words, `parse(format(number))`\n  // must always be equal to `number`.\n  //\n  if (!national_prefix_matcher) {\n    return number;\n  }\n  var national_significant_number = void 0;\n\n  // `national_prefix_for_parsing` capturing groups\n  // (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n  var any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1];\n  var national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata);\n\n  // If the national number tranformation is needed then do it\n  if (national_prefix_transform_rule && any_groups_were_captured) {\n    national_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule);\n  }\n  // Else, no transformation is necessary,\n  // and just strip the national prefix.\n  else {\n    national_significant_number = number.slice(national_prefix_matcher[0].length);\n  }\n\n  // Verify the parsed national (significant) number for this country\n  var national_number_rule = new RegExp(get_national_number_pattern(country_metadata));\n\n  // If the original number (before stripping national prefix) was viable,\n  // and the resultant number is not, then prefer the original phone number.\n  // This is because for some countries (e.g. Russia) the same digit could be both\n  // a national prefix and a leading digit of a valid national phone number,\n  // like `8` is the national prefix for Russia and both\n  // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n  if (matches_entirely(number, national_number_rule) && !matches_entirely(national_significant_number, national_number_rule)) {\n    return number;\n  }\n\n  // Return the parsed national (significant) number\n  return national_significant_number;\n}\nexport function find_country_code(country_phone_code, national_phone_number, metadata) {\n  // Is always non-empty, because `country_phone_code` is always valid\n  var possible_countries = metadata.country_phone_code_to_countries[country_phone_code];\n\n  // If there's just one country corresponding to the country code,\n  // then just return it, without further phone number digits validation.\n  if (possible_countries.length === 1) {\n    return possible_countries[0];\n  }\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n  try {\n    for (var _iterator3 = _getIterator(possible_countries), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var country_code = _step3.value;\n      var country = metadata.countries[country_code];\n\n      // Leading digits check would be the simplest one\n      if (get_leading_digits(country)) {\n        if (national_phone_number && national_phone_number.search(get_leading_digits(country)) === 0) {\n          return country_code;\n        }\n      }\n      // Else perform full validation with all of those bulky\n      // fixed-line/mobile/etc regular expressions.\n      else if (get_number_type({\n        phone: national_phone_number,\n        country: country_code\n      }, metadata)) {\n        return country_code;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\n// export function is_national_prefix_required(national_number, country_metadata)\n// {\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\n//\n// \tif (format)\n// \t{\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\n// \t}\n// }\n\n// Sort out arguments\nfunction sort_out_arguments(arg_1, arg_2, arg_3) {\n  var text = void 0;\n  var options = void 0;\n  var metadata = void 0;\n\n  // Normalize numerical `value`.\n  // https://github.com/catamphetamine/libphonenumber-js/issues/142\n  // `parse(88005553535, ...)`.\n  if (typeof arg_1 === 'number') {\n    arg_1 = String(arg_1);\n  }\n\n  // If the phone number is passed as a string.\n  // `parse('88005553535', ...)`.\n  if (typeof arg_1 === 'string') {\n    text = arg_1;\n  }\n\n  // If \"resrict country\" argument is being passed\n  // then convert it to an `options` object.\n  // `parse('88005553535', 'RU', [options], metadata)`.\n  if (typeof arg_2 === 'string') {\n    options = {\n      country: {\n        restrict: arg_2\n      }\n    };\n    metadata = arg_3;\n  }\n  // No \"resrict country\" argument is being passed.\n  // International phone number is passed.\n  // `parse('+78005553535', [options], metadata)`.\n  else {\n    if (arg_3) {\n      options = arg_2;\n      metadata = arg_3;\n    } else {\n      metadata = arg_2;\n    }\n  }\n\n  // Metadata is required.\n  if (!metadata || !metadata.countries) {\n    throw new Error('Metadata is required');\n  }\n\n  // Apply default options.\n  if (options) {\n    options = _extends({}, default_options, options);\n  } else {\n    options = default_options;\n  }\n  return {\n    text: text,\n    options: options,\n    metadata: metadata\n  };\n}\n\n// Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\nfunction strip_extension(number) {\n  var start = number.search(EXTN_PATTERN);\n  if (start < 0) {\n    return {};\n  }\n\n  // If we find a potential extension, and the number preceding this is a viable\n  // number, we assume it is an extension.\n  var number_without_extension = number.slice(0, start);\n  /* istanbul ignore if - seems a bit of a redundant check */\n  if (!is_viable_phone_number(number_without_extension)) {\n    return {};\n  }\n  var matches = number.match(EXTN_PATTERN);\n  var i = 1;\n  while (i < matches.length) {\n    if (matches[i] != null && matches[i].length > 0) {\n      return {\n        number: number_without_extension,\n        extension: matches[i]\n      };\n    }\n    i++;\n  }\n}\n//# sourceMappingURL=parse.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}