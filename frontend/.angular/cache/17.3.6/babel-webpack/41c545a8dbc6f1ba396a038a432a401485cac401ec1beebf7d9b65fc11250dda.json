{"ast":null,"code":"import _getIterator from 'babel-runtime/core-js/get-iterator';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n// This is an enhanced port of Google Android `libphonenumber`'s\n// `asyoutypeformatter.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\n\nimport { get_phone_code, get_national_prefix, get_national_prefix_for_parsing, get_formats, get_format_pattern, get_format_format as _get_format_format, get_format_international_format, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_mandatory_when_formatting, get_format_leading_digits_patterns, get_format_uses_national_prefix, get_metadata_by_country_phone_code } from './metadata';\nimport { VALID_PUNCTUATION, PLUS_CHARS, VALID_DIGITS, extract_formatted_phone_number, parse_phone_number, parse_phone_number_and_country_phone_code, find_country_code, strip_national_prefix } from './parse';\nimport { FIRST_GROUP_PATTERN, format_national_number_using_format, local_to_international_style } from './format';\nimport { matches_entirely } from './common';\n\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nvar DUMMY_DIGIT = '9';\nvar DUMMY_DIGIT_MATCHER = new RegExp(DUMMY_DIGIT, 'g');\n// I don't know why is it exactly `15`\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;\n// Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);\n\n// The digits that have not been entered yet will be represented by a \\u2008,\n// the punctuation space.\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);\nvar DIGIT_PLACEHOLDER_MATCHER_GLOBAL = new RegExp(DIGIT_PLACEHOLDER, 'g');\n\n// A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\nvar CHARACTER_CLASS_PATTERN = /\\[([^\\[\\]])*\\]/g;\n\n// Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\nvar STANDALONE_DIGIT_PATTERN = /\\d(?=[^,}][^,}])/g;\n\n// A pattern that is used to determine if a `format` is eligible\n// to be used by the \"as you type formatter\".\n// It is eligible when the `format` contains groups of the dollar sign\n// followed by a single digit, separated by valid phone number punctuation.\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\n// getting into the output of the \"as you type formatter\".\nvar ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' + '$');\n\n// This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\nvar MIN_LEADING_DIGITS_LENGTH = 3;\nvar VALID_INCOMPLETE_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\nvar VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i');\nvar as_you_type = function () {\n  function as_you_type(country_code, metadata) {\n    _classCallCheck(this, as_you_type);\n\n    // Metadata is required.\n    if (!metadata || !metadata.countries) {\n      throw new Error('Metadata is required');\n    }\n    if (country_code && metadata.countries[country_code]) {\n      this.default_country = country_code;\n    }\n    this.metadata = metadata;\n    this.reset();\n  }\n  _createClass(as_you_type, [{\n    key: 'input',\n    value: function input(text) {\n      // Parse input\n\n      var extracted_number = extract_formatted_phone_number(text);\n\n      // Special case for a lone '+' sign\n      // since it's not considered a possible phone number.\n      if (!extracted_number) {\n        if (text && text.indexOf('+') >= 0) {\n          extracted_number = '+';\n        }\n      }\n\n      // Validate possible first part of a phone number\n      if (!matches_entirely(extracted_number, VALID_INCOMPLETE_PHONE_NUMBER_PATTERN)) {\n        return this.current_output;\n      }\n      return this.process_input(parse_phone_number(extracted_number));\n    }\n  }, {\n    key: 'process_input',\n    value: function process_input(input) {\n      // If an out of position '+' sign detected\n      // (or a second '+' sign),\n      // then just drop it from the input.\n      if (input[0] === '+') {\n        if (!this.parsed_input) {\n          this.parsed_input += '+';\n\n          // If a default country was set\n          // then reset it because an explicitly international\n          // phone number is being entered\n          this.reset_countriness();\n        }\n        input = input.slice(1);\n      }\n\n      // Raw phone number\n      this.parsed_input += input;\n\n      // // Reset phone number validation state\n      // this.valid = false\n\n      // Add digits to the national number\n      this.national_number += input;\n\n      // Try to format the parsed input\n\n      if (this.is_international()) {\n        if (!this.country_phone_code) {\n          // If one looks at country phone codes\n          // then he can notice that no one country phone code\n          // is ever a (leftmost) substring of another country phone code.\n          // So if a valid country code is extracted so far\n          // then it means that this is the country code.\n\n          // If no country phone code could be extracted so far,\n          // then just return the raw phone number,\n          // because it has no way of knowing\n          // how to format the phone number so far.\n          if (!this.extract_country_phone_code()) {\n            // Return raw phone number\n            return this.parsed_input;\n          }\n\n          // Initialize country-specific data\n          this.initialize_phone_number_formats_for_this_country_phone_code();\n          this.reset_format();\n          this.determine_the_country();\n        }\n        // `this.country` could be `undefined`,\n        // for instance, when there is ambiguity\n        // in a form of several different countries\n        // each corresponding to the same country phone code\n        // (e.g. NANPA: USA, Canada, etc),\n        // and there's not enough digits entered\n        // to reliably determine the country\n        // the phone number belongs to.\n        // Therefore, in cases of such ambiguity,\n        // each time something is input,\n        // try to determine the country\n        // (if it's not determined yet).\n        else if (!this.country) {\n          this.determine_the_country();\n        }\n      } else {\n        // Some national prefixes are substrings of other national prefixes\n        // (for the same country), therefore try to extract national prefix each time\n        // because a longer national prefix might be available at some point in time.\n\n        var previous_national_prefix = this.national_prefix;\n        this.national_number = this.national_prefix + this.national_number;\n\n        // Possibly extract a national prefix\n        this.extract_national_prefix();\n        if (this.national_prefix !== previous_national_prefix) {\n          // National number has changed\n          // (due to another national prefix been extracted)\n          // therefore national number has changed\n          // therefore reset all previous formatting data.\n          // (and leading digits matching state)\n          this.matching_formats = this.available_formats;\n          this.reset_format();\n        }\n      }\n      if (!this.should_format()) {\n        return this.format_as_non_formatted_number();\n      }\n\n      // Check the available phone number formats\n      // based on the currently available leading digits.\n      this.match_formats_by_leading_digits();\n\n      // Format the phone number (given the next digits)\n      var formatted_national_phone_number = this.format_national_phone_number(input);\n\n      // If the phone number could be formatted,\n      // then return it, possibly prepending with country phone code\n      // (for international phone numbers only)\n      if (formatted_national_phone_number) {\n        return this.full_phone_number(formatted_national_phone_number);\n      }\n\n      // If the phone number couldn't be formatted,\n      // then just fall back to the raw phone number.\n      return this.parsed_input;\n    }\n  }, {\n    key: 'format_as_non_formatted_number',\n    value: function format_as_non_formatted_number() {\n      if (this.is_international() && this.country_phone_code) {\n        if (this.national_number) {\n          // For convenience, the public `.template` property\n          // contains the whole international number\n          // if the phone number being input is international:\n          // 'x' for the '+' sign, 'x'es for the country phone code,\n          // a spacebar and then the template for the national number digits.\n          this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + repeat(DIGIT_PLACEHOLDER, this.national_number.length);\n          return '+' + this.country_phone_code + ' ' + this.national_number;\n        }\n        return '+' + this.country_phone_code;\n      }\n      return this.parsed_input;\n    }\n  }, {\n    key: 'format_national_phone_number',\n    value: function format_national_phone_number(next_digits) {\n      // Format the next phone number digits\n      // using the previously chosen phone number format.\n      //\n      // This is done here because if `attempt_to_format_complete_phone_number`\n      // was placed before this call then the `template`\n      // wouldn't reflect the situation correctly (and would therefore be inconsistent)\n      //\n      var national_number_formatted_with_previous_format = void 0;\n      if (this.chosen_format) {\n        national_number_formatted_with_previous_format = this.format_next_national_number_digits(next_digits);\n      }\n\n      // See if the input digits can be formatted properly already. If not,\n      // use the results from format_next_national_number_digits(), which does formatting\n      // based on the formatting pattern chosen.\n\n      var formatted_number = this.attempt_to_format_complete_phone_number();\n\n      // Just because a phone number doesn't have a suitable format\n      // that doesn't mean that the phone is invalid\n      // because phone number formats only format phone numbers,\n      // they don't validate them and some (rare) phone numbers\n      // are meant to stay non-formatted.\n      if (formatted_number) {\n        // if (this.country)\n        // {\n        // \tthis.valid = true\n        // }\n\n        return formatted_number;\n      }\n\n      // For some phone number formats national prefix\n\n      // If the previously chosen phone number format\n      // didn't match the next (current) digit being input\n      // (leading digits pattern didn't match).\n      if (this.choose_another_format()) {\n        // And a more appropriate phone number format\n        // has been chosen for these `leading digits`,\n        // then format the national phone number (so far)\n        // using the newly selected phone number pattern.\n\n        // Will return `undefined` if it couldn't format\n        // the supplied national number\n        // using the selected phone number pattern.\n\n        return this.reformat_national_number();\n      }\n\n      // If could format the next (current) digit\n      // using the previously chosen phone number format\n      // then return the formatted number so far.\n\n      // If no new phone number format could be chosen,\n      // and couldn't format the supplied national number\n      // using the selected phone number pattern,\n      // then it will return `undefined`.\n\n      return national_number_formatted_with_previous_format;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      // Input stripped of non-phone-number characters.\n      // Can only contain a possible leading '+' sign and digits.\n      this.parsed_input = '';\n      this.current_output = '';\n\n      // This contains the national prefix that has been extracted. It contains only\n      // digits without formatting.\n      this.national_prefix = '';\n      this.national_number = '';\n      this.reset_countriness();\n      this.reset_format();\n\n      // this.valid = false\n\n      return this;\n    }\n  }, {\n    key: 'reset_country',\n    value: function reset_country() {\n      if (this.default_country && !this.is_international()) {\n        this.country = this.default_country;\n      } else {\n        this.country = undefined;\n      }\n    }\n  }, {\n    key: 'reset_countriness',\n    value: function reset_countriness() {\n      this.reset_country();\n      if (this.default_country && !this.is_international()) {\n        this.country_metadata = this.metadata.countries[this.default_country];\n        this.country_phone_code = get_phone_code(this.country_metadata);\n        this.initialize_phone_number_formats_for_this_country_phone_code();\n      } else {\n        this.country_metadata = undefined;\n        this.country_phone_code = undefined;\n        this.available_formats = [];\n        this.matching_formats = this.available_formats;\n      }\n    }\n  }, {\n    key: 'reset_format',\n    value: function reset_format() {\n      this.chosen_format = undefined;\n      this.template = undefined;\n      this.partially_populated_template = undefined;\n      this.last_match_position = -1;\n    }\n\n    // Format each digit of national phone number (so far)\n    // using the newly selected phone number pattern.\n  }, {\n    key: 'reformat_national_number',\n    value: function reformat_national_number() {\n      // Format each digit of national phone number (so far)\n      // using the selected phone number pattern.\n      return this.format_next_national_number_digits(this.national_number);\n    }\n  }, {\n    key: 'initialize_phone_number_formats_for_this_country_phone_code',\n    value: function initialize_phone_number_formats_for_this_country_phone_code() {\n      // Get all \"eligible\" phone number formats for this country\n      this.available_formats = get_formats(this.country_metadata).filter(function (format) {\n        return ELIGIBLE_FORMAT_PATTERN.test(get_format_international_format(format));\n      });\n      this.matching_formats = this.available_formats;\n    }\n  }, {\n    key: 'match_formats_by_leading_digits',\n    value: function match_formats_by_leading_digits() {\n      var leading_digits = this.national_number;\n\n      // \"leading digits\" pattern list starts with\n      // one of a maximum length of 3 digits,\n      // and then with each additional digit\n      // a more precise \"leading digits\" pattern is specified.\n\n      var index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH;\n      if (index_of_leading_digits_pattern < 0) {\n        index_of_leading_digits_pattern = 0;\n      }\n      this.matching_formats = this.matching_formats.filter(function (format) {\n        var leading_digits_pattern_count = get_format_leading_digits_patterns(format).length;\n\n        // Keep everything that isn't restricted by leading digits.\n        if (leading_digits_pattern_count === 0) {\n          return true;\n        }\n        var leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_pattern_count - 1);\n        var leading_digits_pattern = get_format_leading_digits_patterns(format)[leading_digits_pattern_index];\n\n        // Brackets are required for `^` to be applied to\n        // all or-ed (`|`) parts, not just the first one.\n        return new RegExp('^(' + leading_digits_pattern + ')').test(leading_digits);\n      });\n\n      // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      if (this.chosen_format && this.matching_formats.indexOf(this.chosen_format) === -1) {\n        this.reset_format();\n      }\n    }\n  }, {\n    key: 'should_format',\n    value: function should_format() {\n      // Start matching any formats at all when the national number\n      // entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives\n      // like when the digits entered so far are `2`\n      // and the leading digits pattern is `21` â€“\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Google could have provided leading digits patterns starting\n      // with a single digit but they chose not to (for whatever reasons).\n      //\n      return this.national_number >= MIN_LEADING_DIGITS_LENGTH;\n    }\n\n    // Check to see if there is an exact pattern match for these digits. If so, we\n    // should use this instead of any other formatting template whose\n    // leadingDigitsPattern also matches the input.\n  }, {\n    key: 'attempt_to_format_complete_phone_number',\n    value: function attempt_to_format_complete_phone_number() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = _getIterator(this.matching_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var format = _step.value;\n          var matcher = new RegExp('^(?:' + get_format_pattern(format) + ')$');\n          if (!matcher.test(this.national_number)) {\n            continue;\n          }\n          if (!this.validate_format(format)) {\n            continue;\n          }\n\n          // To leave the formatter in a consistent state\n          this.reset_format();\n          this.chosen_format = format;\n          var formatted_number = format_national_number_using_format(this.national_number, format, this.is_international(), this.national_prefix.length > 0, this.country_metadata);\n\n          // Set `this.template` and `this.partially_populated_template`.\n          //\n          // `else` case doesn't ever happen\n          // with the current metadata,\n          // but just in case.\n          //\n          /* istanbul ignore else */\n          if (this.create_formatting_template(format)) {\n            // Populate `this.partially_populated_template`\n            this.reformat_national_number();\n          } else {\n            // Prepend `+CountryCode` in case of an international phone number\n            var full_number = this.full_phone_number(formatted_number);\n            this.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER);\n            this.partially_populated_template = full_number;\n          }\n          return formatted_number;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    // Prepends `+CountryCode` in case of an international phone number\n  }, {\n    key: 'full_phone_number',\n    value: function full_phone_number(formatted_national_number) {\n      if (this.is_international()) {\n        return '+' + this.country_phone_code + ' ' + formatted_national_number;\n      }\n      return formatted_national_number;\n    }\n\n    // Extracts the country calling code from the beginning\n    // of the entered `national_number` (so far),\n    // and places the remaining input into the `national_number`.\n  }, {\n    key: 'extract_country_phone_code',\n    value: function extract_country_phone_code() {\n      if (!this.national_number) {\n        return;\n      }\n      var _parse_phone_number_a = parse_phone_number_and_country_phone_code(this.parsed_input, this.metadata),\n        country_phone_code = _parse_phone_number_a.country_phone_code,\n        number = _parse_phone_number_a.number;\n      if (!country_phone_code) {\n        return;\n      }\n      this.country_phone_code = country_phone_code;\n      this.national_number = number;\n      return this.country_metadata = get_metadata_by_country_phone_code(country_phone_code, this.metadata);\n    }\n  }, {\n    key: 'extract_national_prefix',\n    value: function extract_national_prefix() {\n      this.national_prefix = '';\n      if (!this.country_metadata) {\n        return;\n      }\n      var national_number = strip_national_prefix(this.national_number, this.country_metadata);\n      if (national_number !== this.national_number) {\n        this.national_prefix = this.national_number.slice(0, this.national_number.length - national_number.length);\n        this.national_number = national_number;\n      }\n      return this.national_prefix;\n    }\n  }, {\n    key: 'choose_another_format',\n    value: function choose_another_format() {\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = _getIterator(this.matching_formats), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var format = _step2.value;\n\n          // If this format is currently being used\n          // and is still possible, then stick to it.\n          if (this.chosen_format === format) {\n            return;\n          }\n\n          // If this `format` is suitable for \"as you type\",\n          // then extract the template from this format\n          // and use it to format the phone number being input.\n\n          if (!this.validate_format(format)) {\n            continue;\n          }\n          if (!this.create_formatting_template(format)) {\n            continue;\n          }\n          this.chosen_format = format;\n\n          // With a new formatting template, the matched position\n          // using the old template needs to be reset.\n          this.last_match_position = -1;\n          return true;\n        }\n\n        // No format matches the phone number,\n        // therefore set `country` to `undefined`\n        // (or to the default country).\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      this.reset_country();\n\n      // No format matches the national phone number entered\n      this.reset_format();\n    }\n  }, {\n    key: 'validate_format',\n    value: function validate_format(format) {\n      // If national prefix is mandatory for this phone number format\n      // and the user didn't input the national prefix,\n      // then this phone number format isn't suitable.\n      if (!this.is_international() && !this.national_prefix && get_format_national_prefix_is_mandatory_when_formatting(format, this.country_metadata)) {\n        return;\n      }\n      return true;\n    }\n  }, {\n    key: 'create_formatting_template',\n    value: function create_formatting_template(format) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n      /* istanbul ignore if */\n      if (get_format_pattern(format).indexOf('|') >= 0) {\n        return;\n      }\n\n      // Get formatting template for this phone number format\n      var template = this.get_template_for_phone_number_format_pattern(format);\n\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (!template) {\n        return;\n      }\n\n      // This one is for national number only\n      this.partially_populated_template = template;\n\n      // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n      if (this.is_international()) {\n        this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + template;\n      }\n      // For local numbers, replace national prefix\n      // with a digit placeholder.\n      else {\n        this.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER);\n      }\n\n      // This one is for the full phone number\n      return this.template;\n    }\n\n    // Generates formatting template for a phone number format\n  }, {\n    key: 'get_template_for_phone_number_format_pattern',\n    value: function get_template_for_phone_number_format_pattern(format) {\n      var national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata);\n\n      // A very smart trick by the guys at Google\n      var number_pattern = get_format_pattern(format)\n      // Replace anything in the form of [..] with \\d\n      .replace(CHARACTER_CLASS_PATTERN, '\\\\d')\n      // Replace any standalone digit (not the one in `{}`) with \\d\n      .replace(STANDALONE_DIGIT_PATTERN, '\\\\d');\n\n      // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n      var dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0];\n\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (this.national_number.length > dummy_phone_number_matching_format_pattern.length) {\n        return;\n      }\n\n      // Prepare the phone number format\n      var number_format = this.get_format_format(format, national_prefix_formatting_rule);\n\n      // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n\n      // Below `strict_pattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strict_pattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.national_number : `111111111` (9 digits)\n      //\n      // number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // number_format : `$1 $2 $3`\n      // dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `number_pattern`.\n      //\n      // The fix is, if `this.national_number` has already sufficient length\n      // to satisfy the `number_pattern` completely then `this.national_number` is used\n      // instead of `dummy_phone_number_matching_format_pattern`.\n\n      var strict_pattern = new RegExp('^' + number_pattern + '$');\n      var national_number_dummy_digits = this.national_number.replace(/\\d/g, DUMMY_DIGIT);\n\n      // If `this.national_number` has already sufficient length\n      // to satisfy the `number_pattern` completely then use it\n      // instead of `dummy_phone_number_matching_format_pattern`.\n      if (strict_pattern.test(national_number_dummy_digits)) {\n        dummy_phone_number_matching_format_pattern = national_number_dummy_digits;\n      }\n\n      // Generate formatting template for this phone number format\n      return dummy_phone_number_matching_format_pattern\n      // Format the dummy phone number according to the format\n      .replace(new RegExp(number_pattern), number_format)\n      // Replace each dummy digit with a DIGIT_PLACEHOLDER\n      .replace(DUMMY_DIGIT_MATCHER, DIGIT_PLACEHOLDER);\n    }\n  }, {\n    key: 'format_next_national_number_digits',\n    value: function format_next_national_number_digits(digits) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = _getIterator(digits), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var digit = _step3.value;\n\n          // If there is room for more digits in current `template`,\n          // then set the next digit in the `template`,\n          // and return the formatted digits so far.\n\n          // If more digits are entered than the current format could handle\n          if (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1) {\n            // Reset the current format,\n            // so that the new format will be chosen\n            // in a subsequent `this.choose_another_format()` call\n            // later in code.\n            this.chosen_format = undefined;\n            this.template = undefined;\n            this.partially_populated_template = undefined;\n            return;\n          }\n          this.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER);\n          this.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n        }\n\n        // Return the formatted phone number so far\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n      return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1).replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ');\n    }\n  }, {\n    key: 'is_international',\n    value: function is_international() {\n      return this.parsed_input && this.parsed_input[0] === '+';\n    }\n  }, {\n    key: 'get_format_format',\n    value: function get_format_format(format, national_prefix_formatting_rule) {\n      var number_format = this.is_international() ? get_format_international_format(format) : _get_format_format(format);\n\n      // If national prefix formatting rule is set\n      // for this phone number format\n      if (national_prefix_formatting_rule) {\n        // If the user did input the national prefix\n        // (or if the national prefix formatting rule does not require national prefix)\n        // then maybe make it part of the phone number template\n        if (this.national_prefix || !get_format_uses_national_prefix(national_prefix_formatting_rule)) {\n          // Make the national prefix part of the phone number template\n          number_format = number_format.replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule);\n        }\n      }\n      if (this.is_international()) {\n        return local_to_international_style(number_format);\n      }\n      return number_format;\n    }\n\n    // Determines the country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n  }, {\n    key: 'determine_the_country',\n    value: function determine_the_country() {\n      this.country = find_country_code(this.country_phone_code, this.national_number, this.metadata);\n    }\n  }]);\n  return as_you_type;\n}();\nexport default as_you_type;\nexport function close_dangling_braces(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = count_occurences('(', retained_template);\n  var closing_braces = count_occurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n    cut_before++;\n  }\n  return template.slice(0, cut_before);\n}\n\n// Counts all occurences of a symbol in a string\nexport function count_occurences(symbol, string) {\n  var count = 0;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n  try {\n    for (var _iterator4 = _getIterator(string), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var character = _step4.value;\n      if (character === symbol) {\n        count++;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n  return count;\n}\n\n// Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n  var result = '';\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n    times >>= 1;\n    string += string;\n  }\n  return result + string;\n}\n//# sourceMappingURL=AsYouType.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}