{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { Directive, Input, HostBinding, HostListener, NgModule } from '@angular/core';\nconst DEFAULT_RIPPLE_COLOR = [0, 0, 0];\nfunction durationToMsNumber(time) {\n  return Number(time.replace('ms', '').replace('s', '000'));\n}\nfunction colorToRGB(color) {\n  // eslint-disable-next-line no-shadow,@typescript-eslint/no-shadow\n  function hexToRgb(color) {\n    const HEX_COLOR_LENGTH = 7;\n    const IS_SHORT_HEX = color.length < HEX_COLOR_LENGTH;\n    if (IS_SHORT_HEX) {\n      color = `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;\n    }\n    return [parseInt(color.substr(1, 2), 16), parseInt(color.substr(3, 2), 16), parseInt(color.substr(5, 2), 16)];\n  }\n  // eslint-disable-next-line no-shadow,@typescript-eslint/no-shadow\n  function namedColorsToRgba(color) {\n    const tempElem = document.body.appendChild(document.createElement('fictum'));\n    const flag = 'rgb(1, 2, 3)';\n    tempElem.style.color = flag;\n    if (tempElem.style.color !== flag) {\n      return DEFAULT_RIPPLE_COLOR;\n    }\n    tempElem.style.color = color;\n    if (tempElem.style.color === flag || tempElem.style.color === '') {\n      return DEFAULT_RIPPLE_COLOR;\n    } // color parse failed\n    color = getComputedStyle(tempElem).color;\n    document.body.removeChild(tempElem);\n    return color;\n  }\n  // eslint-disable-next-line no-shadow, @typescript-eslint/no-shadow\n  function rgbaToRgb(color) {\n    color = color.match(/[.\\d]+/g).map(a => +Number(a));\n    color.length = 3;\n    return color;\n  }\n  if (color.toLowerCase() === 'transparent') {\n    return DEFAULT_RIPPLE_COLOR;\n  }\n  if (color[0] === '#') {\n    return hexToRgb(color);\n  }\n  if (color.indexOf('rgb') === -1) {\n    color = namedColorsToRgba(color);\n  }\n  if (color.indexOf('rgb') === 0) {\n    return rgbaToRgb(color);\n  }\n  return DEFAULT_RIPPLE_COLOR;\n}\nfunction getDiameter({\n  offsetX,\n  offsetY,\n  height,\n  width\n}) {\n  const top = offsetY <= height / 2;\n  const left = offsetX <= width / 2;\n  const pythagorean = (sideA, sideB) => Math.sqrt(sideA ** 2 + sideB ** 2);\n  const positionCenter = offsetY === height / 2 && offsetX === width / 2;\n  // mouse position on the quadrants of the coordinate system\n  const quadrant = {\n    first: top === true && left === false,\n    second: top === true && left === true,\n    third: top === false && left === true,\n    fourth: top === false && left === false\n  };\n  const getCorner = {\n    topLeft: pythagorean(offsetX, offsetY),\n    topRight: pythagorean(width - offsetX, offsetY),\n    bottomLeft: pythagorean(offsetX, height - offsetY),\n    bottomRight: pythagorean(width - offsetX, height - offsetY)\n  };\n  let diameter = 0;\n  if (positionCenter || quadrant.fourth) {\n    diameter = getCorner.topLeft;\n  } else if (quadrant.third) {\n    diameter = getCorner.topRight;\n  } else if (quadrant.second) {\n    diameter = getCorner.bottomRight;\n  } else if (quadrant.first) {\n    diameter = getCorner.bottomLeft;\n  }\n  return diameter * 2;\n}\nconst TRANSITION_BREAK_OPACITY = 0.5;\nconst GRADIENT = 'rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%';\nconst BOOTSTRAP_COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark'];\nlet MdbRippleDirective = /*#__PURE__*/(() => {\n  class MdbRippleDirective {\n    _elementRef;\n    _renderer;\n    get rippleCentered() {\n      return this._rippleCentered;\n    }\n    set rippleCentered(value) {\n      this._rippleCentered = coerceBooleanProperty(value);\n    }\n    _rippleCentered = false;\n    rippleColor = '';\n    rippleDuration = '500ms';\n    rippleRadius = 0;\n    get rippleUnbound() {\n      return this._rippleUnbound;\n    }\n    set rippleUnbound(value) {\n      this._rippleUnbound = coerceBooleanProperty(value);\n    }\n    _rippleUnbound = false;\n    _rippleInSpan = false;\n    _rippleTimer = null;\n    constructor(_elementRef, _renderer) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n    }\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n    ripple = true;\n    _createRipple(event) {\n      const {\n        layerX,\n        layerY\n      } = event;\n      const offsetX = layerX;\n      const offsetY = layerY;\n      const height = this.host.offsetHeight;\n      const width = this.host.offsetWidth;\n      const duration = durationToMsNumber(this.rippleDuration);\n      const diameterOptions = {\n        offsetX: this.rippleCentered ? height / 2 : offsetX,\n        offsetY: this.rippleCentered ? width / 2 : offsetY,\n        height,\n        width\n      };\n      const diameter = getDiameter(diameterOptions);\n      const radiusValue = this.rippleRadius || diameter / 2;\n      const opacity = {\n        delay: duration * TRANSITION_BREAK_OPACITY,\n        duration: duration - duration * TRANSITION_BREAK_OPACITY\n      };\n      const styles = {\n        left: this.rippleCentered ? `${width / 2 - radiusValue}px` : `${offsetX - radiusValue}px`,\n        top: this.rippleCentered ? `${height / 2 - radiusValue}px` : `${offsetY - radiusValue}px`,\n        height: `${this.rippleRadius * 2 || diameter}px`,\n        width: `${this.rippleRadius * 2 || diameter}px`,\n        transitionDelay: `0s, ${opacity.delay}ms`,\n        transitionDuration: `${duration}ms, ${opacity.duration}ms`\n      };\n      const rippleHTML = this._renderer.createElement('div');\n      if (this.host.tagName.toLowerCase() === 'input') {\n        this._createWrapperSpan();\n      }\n      this._createHTMLRipple(this.host, rippleHTML, styles);\n      this._removeHTMLRipple(rippleHTML, duration);\n    }\n    _createWrapperSpan() {\n      const parent = this._renderer.parentNode(this.host);\n      this._rippleInSpan = true;\n      if (parent.tagName.toLowerCase() === 'span' && parent.classList.contains('ripple-surface')) {\n        this._elementRef.nativeElement = parent;\n      } else {\n        const wrapper = this._renderer.createElement('span');\n        this._renderer.addClass(wrapper, 'ripple-surface');\n        this._renderer.addClass(wrapper, 'input-wrapper');\n        this._renderer.setStyle(wrapper, 'border', 0);\n        const shadow = getComputedStyle(this.host).boxShadow;\n        this._renderer.setStyle(wrapper, 'box-shadow', shadow);\n        // Put element as child\n        parent.replaceChild(wrapper, this.host);\n        wrapper.appendChild(this.host);\n        this._elementRef.nativeElement = wrapper;\n      }\n      this.host.focus();\n    }\n    _removeWrapperSpan() {\n      const child = this.host.firstChild;\n      this.host.replaceWith(child);\n      this._elementRef.nativeElement = child;\n      this.host.focus();\n      this._rippleInSpan = false;\n    }\n    _createHTMLRipple(wrapper, ripple, styles) {\n      Object.keys(styles).forEach(property => ripple.style[property] = styles[property]);\n      this._renderer.addClass(ripple, 'ripple-wave');\n      if (this.rippleColor !== '') {\n        this._removeOldColorClasses(wrapper);\n        this._addColor(ripple, wrapper);\n      }\n      this._toggleUnbound(wrapper);\n      this._appendRipple(ripple, wrapper);\n    }\n    _removeHTMLRipple(ripple, duration) {\n      if (this._rippleTimer) {\n        clearTimeout(this._rippleTimer);\n        this._rippleTimer = null;\n      }\n      this._rippleTimer = setTimeout(() => {\n        if (ripple) {\n          ripple.remove();\n          this.host.querySelectorAll('.ripple-wave').forEach(rippleEl => {\n            rippleEl.remove();\n          });\n          if (this._rippleInSpan && this.host.classList.contains('input-wrapper')) {\n            this._removeWrapperSpan();\n          }\n        }\n      }, duration);\n    }\n    _appendRipple(target, parent) {\n      const FIX_ADD_RIPPLE_EFFECT = 50; // delay for active animations\n      this._renderer.appendChild(parent, target);\n      setTimeout(() => {\n        this._renderer.addClass(target, 'active');\n      }, FIX_ADD_RIPPLE_EFFECT);\n    }\n    _toggleUnbound(target) {\n      if (this.rippleUnbound) {\n        this._renderer.addClass(target, 'ripple-surface-unbound');\n      } else {\n        this._renderer.removeClass(target, 'ripple-surface-unbound');\n      }\n    }\n    _addColor(target, parent) {\n      const isBootstrapColor = BOOTSTRAP_COLORS.find(color => color === this.rippleColor.toLowerCase());\n      if (isBootstrapColor) {\n        this._renderer.addClass(parent, `${'ripple-surface'}-${this.rippleColor.toLowerCase()}`);\n      } else {\n        const rgbValue = colorToRGB(this.rippleColor).join(',');\n        const gradientImage = GRADIENT.split('{{color}}').join(`${rgbValue}`);\n        target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;\n      }\n    }\n    _removeOldColorClasses(target) {\n      const REGEXP_CLASS_COLOR = new RegExp(`${'ripple-surface'}-[a-z]+`, 'gi');\n      const PARENT_CLASSS_COLOR = target.classList.value.match(REGEXP_CLASS_COLOR) || [];\n      PARENT_CLASSS_COLOR.forEach(className => {\n        this._renderer.removeClass(target, className);\n      });\n    }\n    static ngAcceptInputType_rippleCentered;\n    static ngAcceptInputType_rippleUnbound;\n    static ɵfac = function MdbRippleDirective_Factory(t) {\n      return new (t || MdbRippleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbRippleDirective,\n      selectors: [[\"\", \"mdbRipple\", \"\"]],\n      hostVars: 2,\n      hostBindings: function MdbRippleDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MdbRippleDirective_click_HostBindingHandler($event) {\n            return ctx._createRipple($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ripple-surface\", ctx.ripple);\n        }\n      },\n      inputs: {\n        rippleCentered: \"rippleCentered\",\n        rippleColor: \"rippleColor\",\n        rippleDuration: \"rippleDuration\",\n        rippleRadius: \"rippleRadius\",\n        rippleUnbound: \"rippleUnbound\"\n      },\n      exportAs: [\"mdbRipple\"]\n    });\n  }\n  return MdbRippleDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbRippleModule = /*#__PURE__*/(() => {\n  class MdbRippleModule {\n    static ɵfac = function MdbRippleModule_Factory(t) {\n      return new (t || MdbRippleModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MdbRippleModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return MdbRippleModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MdbRippleDirective, MdbRippleModule };\n//# sourceMappingURL=mdb-angular-ui-kit-ripple.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}