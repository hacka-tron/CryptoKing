{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, EventEmitter, Output, Input, booleanAttribute, numberAttribute, ElementRef, Component, ChangeDetectionStrategy, ViewChild, ContentChild, NgModule } from '@angular/core';\nimport * as i1 from '@angular/cdk/overlay';\nimport { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil, filter } from 'rxjs/operators';\nimport { style, state, animate, transition, trigger } from '@angular/animations';\nimport * as i2 from '@angular/cdk/layout';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"dropdownTemplate\"];\nconst _c1 = [\"mdbDropdown\", \"\"];\nconst _c2 = [\"*\", [[\"\", 8, \"dropdown-toggle\"]], [[\"\", 8, \"dropdown-menu\"]]];\nconst _c3 = [\"*\", \".dropdown-toggle\", \".dropdown-menu\"];\nfunction MdbDropdownDirective_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵlistener(\"@fade.done\", function MdbDropdownDirective_ng_template_2_Template_div_animation_fade_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onAnimationEnd($event));\n    });\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@fade\", ctx_r1._animationState)(\"@.disabled\", !ctx_r1.animation);\n  }\n}\nlet MdbDropdownToggleDirective = /*#__PURE__*/(() => {\n  class MdbDropdownToggleDirective {\n    constructor() {}\n    static ɵfac = function MdbDropdownToggleDirective_Factory(t) {\n      return new (t || MdbDropdownToggleDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbDropdownToggleDirective,\n      selectors: [[\"\", \"mdbDropdownToggle\", \"\"]],\n      exportAs: [\"mdbDropdownToggle\"]\n    });\n  }\n  return MdbDropdownToggleDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet MdbDropdownMenuDirective = /*#__PURE__*/(() => {\n  class MdbDropdownMenuDirective {\n    elementRef;\n    _renderer;\n    constructor(elementRef, _renderer) {\n      this.elementRef = elementRef;\n      this._renderer = _renderer;\n    }\n    menuPositionClassChanged = new EventEmitter();\n    get menuPositionClass() {\n      return this._menuPositionClass;\n    }\n    set menuPositionClass(newClass) {\n      const host = this.elementRef.nativeElement;\n      const isSameClass = host.classList.contains(newClass);\n      if (this._menuPositionClass !== newClass && !isSameClass) {\n        const menuPositionClasses = ['dropdown-menu-start', 'dropdown-menu-sm-start', 'dropdown-menu-md-start', 'dropdown-menu-lg-start', 'dropdown-menu-xl-start', 'dropdown-menu-xxl-start', 'dropdown-menu-xxl-start', 'dropdown-menu-xxl-start', 'dropdown-menu-end', 'dropdown-menu-sm-end', 'dropdown-menu-md-end', 'dropdown-menu-lg-end', 'dropdown-menu-xl-end', 'dropdown-menu-xxl-end', 'dropdown-menu-xxl-end', 'dropdown-menu-xxl-end'];\n        menuPositionClasses.forEach(className => {\n          this._renderer.removeClass(host, className);\n        });\n        this._renderer.addClass(host, newClass);\n        this.menuPositionClassChanged.emit(this.menuPositionClass);\n      }\n    }\n    _menuPositionClass;\n    static ɵfac = function MdbDropdownMenuDirective_Factory(t) {\n      return new (t || MdbDropdownMenuDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbDropdownMenuDirective,\n      selectors: [[\"\", \"mdbDropdownMenu\", \"\"]],\n      inputs: {\n        menuPositionClass: \"menuPositionClass\"\n      },\n      outputs: {\n        menuPositionClassChanged: \"menuPositionClassChanged\"\n      },\n      exportAs: [\"mdbDropdownMenu\"]\n    });\n  }\n  return MdbDropdownMenuDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet MdbDropdownDirective = /*#__PURE__*/(() => {\n  class MdbDropdownDirective {\n    _overlay;\n    _overlayPositionBuilder;\n    _elementRef;\n    _vcr;\n    _breakpointObserver;\n    _cdRef;\n    _renderer;\n    _template;\n    _dropdownToggle;\n    _dropdownMenu;\n    animation = true;\n    closeOnEsc = true;\n    closeOnItemClick = true;\n    closeOnOutsideClick = true;\n    offset = 0;\n    get positionClass() {\n      return this._positionClass;\n    }\n    set positionClass(newClass) {\n      const isSameClass = this.host.classList.contains(newClass);\n      if (this._positionClass !== newClass && !isSameClass) {\n        const positionClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n        positionClasses.forEach(className => {\n          this._renderer.removeClass(this.host, className);\n        });\n        this._renderer.addClass(this.host, newClass);\n      }\n      this._updateOverlay();\n    }\n    _positionClass;\n    withPush = false;\n    dropdownShow = new EventEmitter();\n    dropdownShown = new EventEmitter();\n    dropdownHide = new EventEmitter();\n    dropdownHidden = new EventEmitter();\n    _overlayRef;\n    _portal;\n    _open = false;\n    _isDropUp;\n    _isDropStart;\n    _isDropEnd;\n    _isDropdownMenuEnd;\n    _xPosition;\n    _breakpoints;\n    _destroy$ = new Subject();\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n    _breakpointSubscription;\n    _animationState = 'hidden';\n    constructor(_overlay, _overlayPositionBuilder, _elementRef, _vcr, _breakpointObserver, _cdRef, _renderer) {\n      this._overlay = _overlay;\n      this._overlayPositionBuilder = _overlayPositionBuilder;\n      this._elementRef = _elementRef;\n      this._vcr = _vcr;\n      this._breakpointObserver = _breakpointObserver;\n      this._cdRef = _cdRef;\n      this._renderer = _renderer;\n      this._breakpoints = {\n        isSm: this._breakpointObserver.isMatched('(min-width: 576px)'),\n        isMd: this._breakpointObserver.isMatched('(min-width: 768px)'),\n        isLg: this._breakpointObserver.isMatched('(min-width: 992px)'),\n        isXl: this._breakpointObserver.isMatched('(min-width: 1200px)'),\n        isXxl: this._breakpointObserver.isMatched('(min-width: 1400px)')\n      };\n    }\n    ngAfterContentInit() {\n      this._bindDropdownToggleClick();\n      this._listenToMenuPositionClassChange();\n    }\n    ngOnDestroy() {\n      if (this._overlayRef) {\n        this._overlayRef.detach();\n        this._overlayRef.dispose();\n      }\n      this._destroy$.next();\n      this._destroy$.complete();\n    }\n    _bindDropdownToggleClick() {\n      fromEvent(this._dropdownToggle.nativeElement, 'click').pipe(takeUntil(this._destroy$)).subscribe(() => this.toggle());\n    }\n    _listenToMenuPositionClassChange() {\n      this._dropdownMenu.menuPositionClassChanged.pipe(takeUntil(this._destroy$)).subscribe(() => this._updateOverlay());\n    }\n    _updateOverlay() {\n      this._overlayRef?.updatePositionStrategy(this._createPositionStrategy());\n    }\n    _createOverlayConfig() {\n      return new OverlayConfig({\n        hasBackdrop: false,\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        positionStrategy: this._createPositionStrategy()\n      });\n    }\n    _createOverlay() {\n      this._overlayRef = this._overlay.create(this._createOverlayConfig());\n    }\n    _createPositionStrategy() {\n      const positionStrategy = this._overlayPositionBuilder.flexibleConnectedTo(this._dropdownToggle).withPositions(this._getPosition()).withFlexibleDimensions(false).withPush(this.withPush);\n      return positionStrategy;\n    }\n    _getPosition() {\n      this._isDropUp = this.host.classList.contains('dropup');\n      this._isDropStart = this.host.classList.contains('dropstart');\n      this._isDropEnd = this.host.classList.contains('dropend');\n      this._isDropdownMenuEnd = this._dropdownMenu.elementRef.nativeElement.classList.contains('dropdown-menu-end');\n      this._xPosition = this._isDropdownMenuEnd ? 'end' : 'start';\n      const regex = new RegExp(/dropdown-menu-(sm|md|lg|xl|xxl)-(start|end)/, 'g');\n      const responsiveClass = this._dropdownMenu.elementRef.nativeElement.className.match(regex);\n      if (responsiveClass) {\n        this._subscribeBrakpoints();\n        const positionRegex = new RegExp(/start|end/, 'g');\n        const breakpointRegex = new RegExp(/(sm|md|lg|xl|xxl)/, 'g');\n        const dropdownPosition = positionRegex.exec(responsiveClass)[0];\n        const breakpoint = breakpointRegex.exec(responsiveClass)[0];\n        switch (true) {\n          case breakpoint === 'xxl' && this._breakpoints.isXxl:\n            this._xPosition = dropdownPosition;\n            break;\n          case breakpoint === 'xl' && this._breakpoints.isXl:\n            this._xPosition = dropdownPosition;\n            break;\n          case breakpoint === 'lg' && this._breakpoints.isLg:\n            this._xPosition = dropdownPosition;\n            break;\n          case breakpoint === 'md' && this._breakpoints.isMd:\n            this._xPosition = dropdownPosition;\n            break;\n          case breakpoint === 'sm' && this._breakpoints.isSm:\n            this._xPosition = dropdownPosition;\n            break;\n          default:\n            break;\n        }\n      }\n      let position;\n      const positionDropup = {\n        originX: this._xPosition,\n        originY: 'top',\n        overlayX: this._xPosition,\n        overlayY: 'bottom',\n        offsetY: -this.offset\n      };\n      const positionDropdown = {\n        originX: this._xPosition,\n        originY: 'bottom',\n        overlayX: this._xPosition,\n        overlayY: 'top',\n        offsetY: this.offset\n      };\n      const positionDropstart = {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'top',\n        offsetX: this.offset\n      };\n      const positionDropend = {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'top',\n        offsetX: -this.offset\n      };\n      switch (true) {\n        case this._isDropEnd:\n          position = [positionDropend, positionDropstart];\n          break;\n        case this._isDropStart:\n          position = [positionDropstart, positionDropend];\n          break;\n        case this._isDropUp:\n          position = [positionDropup, positionDropdown];\n          break;\n        default:\n          position = [positionDropdown, positionDropup];\n          break;\n      }\n      return position;\n    }\n    _listenToEscKeyup(overlayRef) {\n      return fromEvent(document, 'keyup').pipe(filter(event => event.key === 'Escape'), takeUntil(overlayRef.detachments()));\n    }\n    _listenToClick(overlayRef, origin) {\n      return fromEvent(document, 'click').pipe(filter(event => {\n        const target = event.target;\n        const isInsideMenu = this._dropdownMenu.elementRef.nativeElement.contains(target);\n        const notTogglerIcon = !this._dropdownToggle.nativeElement.contains(target);\n        const notCustomContent = !isInsideMenu || target.classList && target.classList.contains('dropdown-item');\n        const notOrigin = target !== origin;\n        return notOrigin && notTogglerIcon && notCustomContent;\n      }), takeUntil(overlayRef.detachments()));\n    }\n    onAnimationEnd(event) {\n      if (event.fromState === 'visible' && event.toState === 'hidden') {\n        this._overlayRef.detach();\n        this._open = false;\n        this.dropdownHidden.emit(this);\n      }\n      if (event.fromState === 'hidden' && event.toState === 'visible') {\n        this.dropdownShown.emit(this);\n      }\n    }\n    _subscribeBrakpoints() {\n      const brakpoints = ['(min-width: 576px)', '(min-width: 768px)', '(min-width: 992px)', '(min-width: 1200px)', '(min-width: 1400px)'];\n      this._breakpointSubscription = this._breakpointObserver.observe(brakpoints).pipe(takeUntil(this._destroy$)).subscribe(result => {\n        Object.keys(this._breakpoints).forEach((key, index) => {\n          const brakpointValue = brakpoints[index];\n          const newBreakpoint = result.breakpoints[brakpointValue];\n          const isBreakpointChanged = newBreakpoint !== this._breakpoints[key];\n          if (!isBreakpointChanged) {\n            return;\n          }\n          this._breakpoints[key] = newBreakpoint;\n          if (this._open) {\n            this._updateOverlay();\n          }\n        });\n      });\n    }\n    show() {\n      this._cdRef.markForCheck();\n      if (this._open) {\n        return;\n      }\n      if (!this._overlayRef) {\n        this._createOverlay();\n      }\n      this._portal = new TemplatePortal(this._template, this._vcr);\n      this.dropdownShow.emit(this);\n      this._open = true;\n      this._overlayRef.attach(this._portal);\n      this._listenToEscKeyup(this._overlayRef).subscribe(isEsc => {\n        if (isEsc && this.closeOnEsc) {\n          this.hide();\n        }\n      });\n      this._overlayRef.keydownEvents().pipe(takeUntil(this._overlayRef.detachments())).subscribe(event => {\n        this._handleKeyboardNavigation(event);\n      });\n      this._listenToClick(this._overlayRef, this._dropdownToggle.nativeElement).subscribe(event => {\n        const target = event.target;\n        const isDropdownItem = target.classList && target.classList.contains('dropdown-item');\n        if (this.closeOnItemClick && isDropdownItem) {\n          this.hide();\n          return;\n        }\n        if (this.closeOnOutsideClick && !isDropdownItem) {\n          this.hide();\n          return;\n        }\n      });\n      this._animationState = 'visible';\n    }\n    _handleKeyboardNavigation(event) {\n      const items = Array.from(this._dropdownMenu.elementRef.nativeElement.querySelectorAll('.dropdown-item'));\n      const key = event.key;\n      const activeElement = this._dropdownMenu.elementRef.nativeElement.ownerDocument.activeElement;\n      if (items.length === 0) {\n        return;\n      }\n      let index = items.indexOf(activeElement);\n      switch (key) {\n        case 'ArrowDown':\n          event.preventDefault();\n          index = Math.min(index + 1, items.length - 1);\n          break;\n        case 'ArrowUp':\n          event.preventDefault();\n          if (index === -1) {\n            index = items.length - 1;\n            break;\n          }\n          index = Math.max(index - 1, 0);\n          break;\n      }\n      const nextActiveElement = items[index];\n      if (nextActiveElement) {\n        nextActiveElement.focus();\n      }\n    }\n    hide() {\n      this._cdRef.markForCheck();\n      if (!this._open) {\n        return;\n      }\n      this.dropdownHide.emit(this);\n      this._animationState = 'hidden';\n    }\n    toggle() {\n      this._cdRef.markForCheck();\n      if (this._open) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n    static ɵfac = function MdbDropdownDirective_Factory(t) {\n      return new (t || MdbDropdownDirective)(i0.ɵɵdirectiveInject(i1.Overlay), i0.ɵɵdirectiveInject(i1.OverlayPositionBuilder), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2.BreakpointObserver), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MdbDropdownDirective,\n      selectors: [[\"\", \"mdbDropdown\", \"\"]],\n      contentQueries: function MdbDropdownDirective_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MdbDropdownToggleDirective, 5, ElementRef);\n          i0.ɵɵcontentQuery(dirIndex, MdbDropdownMenuDirective, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dropdownToggle = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dropdownMenu = _t.first);\n        }\n      },\n      viewQuery: function MdbDropdownDirective_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._template = _t.first);\n        }\n      },\n      inputs: {\n        animation: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"animation\", \"animation\", booleanAttribute],\n        closeOnEsc: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"closeOnEsc\", \"closeOnEsc\", booleanAttribute],\n        closeOnItemClick: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"closeOnItemClick\", \"closeOnItemClick\", booleanAttribute],\n        closeOnOutsideClick: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"closeOnOutsideClick\", \"closeOnOutsideClick\", booleanAttribute],\n        offset: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"offset\", \"offset\", numberAttribute],\n        positionClass: \"positionClass\",\n        withPush: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"withPush\", \"withPush\", booleanAttribute]\n      },\n      outputs: {\n        dropdownShow: \"dropdownShow\",\n        dropdownShown: \"dropdownShown\",\n        dropdownHide: \"dropdownHide\",\n        dropdownHidden: \"dropdownHidden\"\n      },\n      features: [i0.ɵɵInputTransformsFeature],\n      attrs: _c1,\n      ngContentSelectors: _c3,\n      decls: 4,\n      vars: 0,\n      consts: [[\"dropdownTemplate\", \"\"]],\n      template: function MdbDropdownDirective_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c2);\n          i0.ɵɵprojection(0);\n          i0.ɵɵprojection(1, 1);\n          i0.ɵɵtemplate(2, MdbDropdownDirective_ng_template_2_Template, 2, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        }\n      },\n      encapsulation: 2,\n      data: {\n        animation: [trigger('fade', [state('visible', style({\n          opacity: 1\n        })), state('hidden', style({\n          opacity: 0\n        })), transition('visible => hidden', animate('150ms linear')), transition('hidden => visible', [style({\n          opacity: 0\n        }), animate('150ms linear')])])]\n      },\n      changeDetection: 0\n    });\n  }\n  return MdbDropdownDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbDropdownModule = /*#__PURE__*/(() => {\n  class MdbDropdownModule {\n    static ɵfac = function MdbDropdownModule_Factory(t) {\n      return new (t || MdbDropdownModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MdbDropdownModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, OverlayModule]\n    });\n  }\n  return MdbDropdownModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MdbDropdownDirective, MdbDropdownMenuDirective, MdbDropdownModule, MdbDropdownToggleDirective };\n//# sourceMappingURL=mdb-angular-ui-kit-dropdown.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}